---
title:  自然语言检索-双数组
cover: https://images.xianhu.wang/20220907.jpg
date:  2022-09-07 14:39:10
updated: 2022-09-07 14:50:00
tags:
  - doubleArray
categories:
  - doubleArray
---

{% note red 'fas fa-fan' disabled %} ## trie树{% endnote %}

{% note red  'fas -fa-fan' flat%} 
Trie 树中文名叫字典树、前缀树，它主要用途就是将所有的字符串或其他数据结构的数据按照公共前缀的方式构建成树。例如`ab、abc、abcd、ef`构建成trie树的数据格式如下：
{% endnote %}
{%image https://images.xianhu.wang/trie.png %}

{% note red 'fas fa-fan' disabled %} ## trie特点{% endnote %}
{% note red  'fas -fa-fan' flat%} 
1.除根节点外每一个节点都只包含一个字符。从根节点到叶子节点，路径上经过的字符连接起来，构成一个词。叶子节点内的数字代表该词在字典树中所处的链路（字典中有多少个词就有多少条链路），具有共同前缀的链路称为串。
2.具有相同前缀的词必须位于同一个串内；例如“ab”、“ad”两个词都有“a”这个前缀，那么在 Trie 树上只需构建一个“a”节点，“b”和“d”节点共用一个父节点即可，如此两个词便只需三个节点便可存储，这在一定程度上减少了字典的存储空间。
3.Trie 树中任何一个完整的词，都必须是从根节点开始至叶子节点结束，这意味着对一个词进行检索也必须从根节点开始，至叶子节点才算结束。
4.Trie 树中的词只可共用前缀，不可共用词的其他部分；例如“ab”、“bc”这两个词虽然前一个词的后缀是后一个词的前缀，但在树形上必须是独立的两条链路，而不可以通过首尾交接构建这两个词，这也说明 Trie 树仅能依靠公共前缀压缩字典的存储空间，并不能共享词中的所有相同的字符
{% endnote %}


{% note red 'fas fa-fan' disabled %} ## trie树搜索时间复杂度{% endnote %}
在 Trie 树中搜索一个字符串，会从根节点出发，沿着某条链路向下逐字比对字符串的每个字符，直到抵达底部的叶子节点才能确认字符串为该词，这种检索方式具有以下两个优点：

公共前缀的词都位于同一个串内，查词范围因此被大幅缩小（比如首字不同的字符串，都会被排除）。
Trie 树实质是一个有限状态自动机（(Definite Automata, DFA），这就意味着从 Trie 树的一个节点（状态）转移到另一个节点（状态）的行为完全由状态转移函数控制，而状态转移函数本质上是一种映射，这意味着：逐字搜索 Trie 树时，从一个字符到下一个字符比对是不需要遍历该节点的所有子节点的。对于确定性有限自动机感兴趣的同学，可以看看以下引用[1]：
确定的有限自动机 M 是一个五元组：
M = (Σ, Q, δ, q0, F)
其中，Σ 是输入符号的有穷集合；
Q 是状态的有限集合；
δ 是 Q 与 Σ 的直积 Q × Σ 到Q (下一个状态) 的映射。它支配着有限状态控制的行为，有时也称为状态>转移函数。
q0 ∈ Q 是初始状态；
F 是终止状态集合，F ⊆ Q；
可以把DFA想象成一个单放机，插入一盘磁带，随着磁带的转动，DFA读取一个符号，依靠状态转移函数>改变自己的状态，同时磁带转到下一个字符。
这两个优点相结合可以最大限度地减少无谓的字符比较，使得搜索的时间复杂度理论上仅与检索词的长度有关：O(m)，其中 m 为检索词的长度。

{% note red 'fas fa-fan' disabled %} ## trie的缺点{% endnote %}
Trie 树主要是利用词的公共前缀缩小查词范围、通过状态间的映射关系避免了字符的遍历，从而达到高效检索的目的。这一思想有赖于字符在词中的前后位置能够得到表达，因此其设计哲学是典型的“以信息换时间”，当然，这种优势同样是需要付出代价的：

由于结构需要记录更多的信息，因此 Trie 树的实现稍显复杂。好在这点在大多数情况下并非不可接受。

Trie 型词典不仅需要记录词，还需要记录字符之间、词之间的相关信息，因此字典构建时必须对每个词和字逐一进行处理，而这无疑会减慢词典的构建速度。对于强调实时更新的词典而言，这点可能是致命的，尤其是采用双数组实现的 Trie 树，更新词典很大概率会造成词典的全部重构，词典构建过程中还需处理各种冲突，因此重构的时间非常长，这导致其大多用于离线；不过也有一些 Trie 可以实现实时更新，但也需付出一定的代价，因此这个缺点一定程度上影响了 Trie 树的应用范围。

公共前缀虽然可以减少一定的存储空间，但 Trie 树相比普通字典还需表达词、字之间的各种关系，其实现也更加复杂，因此实际空间消耗相对更大（大多少，得根据具体实现而定）。尤其是早期的“Array Trie”，属于典型的以空间换时间的实现，（其实 Trie 本身的实现思想是是以信息换时间，而非以空间换时间，这就给 Trie 树的改进提供了可能），然而 Trie 树现今已经得到了很好的改进，总体来说，对于类似词典这样的应用，Trie 是一个优秀的数据结构。

{% note red 'fas fa-fan' disabled %} ## trie的实现{% endnote %}
### ArrayTrie树
ArrayTrie树是trie树的一种经典实现。如下图：abc、d、da、dda 四个字符串构成的 Trie 树，如果是字符串会在节点的尾部进行标记。没有后续字符的 branch 分支指向NULL
{%image https://images.xianhu.wang/trie02.jpeg %}
如上图，这种实现的特点是：每个节点都由指针数组存储，每个节点的所有子节点都位于一个数组之中，每个数组都是完全一样的。对于英文而言，每个数组有27个指针，其中一个作为词的终结符，另外26个依次代表字母表中的一个字母，对应指针指向下一个状态，若没有后续字符则指向NULL。由于数组取词的复杂度为O(1)，因此这种实现的Trie树效率非常的高，比如要在一个节点中写入字符“c”,则直接在相应数组的第三个位置标入状态即可，而要确定字母“b”是否在现有节点的子节点之中，检查子节点所在数组第二个元素是否为空即可，这种实现巧妙的利用了等长数组中元素位置和值的一一对应关系，完美的实现了了寻址、存值、取值的统一。
但其缺点也很明显，它强制要求链路每一层都要有一个数组，每个数组都必须等长，这在实际应用中会造成大多数的数组指针空置（从上图就可以看出），事实上，对于真实的词典而言，公共前缀相对于节点数量而言还是太少，这导致绝大多数节点下并没有太多子节点。而对于中文这样具有大量单字的语言，若采取这样的实现，空置指针的数量简直不可想象。因此，经典Trie树是一种典型的以“空间换时间”的实现方式。一般只是拿来用于课程设计和新手练习，很少实际应用。

### ListTrie树
由于数组的长度是不可变，因此经典 Trie 树存在着明显的空间浪费。但是如果将每一层都换成可变数组（不同语言对这种数据结构称呼不同，比如在 Python 中为List，C# 称为 LinkedList）来存储节点，每层可以根据节点的数量动态调整数组的长度，就可以避免大量的空间浪费。下图就是这种实现的图例：
{%image https://images.xianhu.wang/trie03.png %}
但是可变长数组的取词复杂度是O(d),其中d为数组的长度，这意味着状态转移函数无法通过映射转移到下一节点，必须先遍历数组，找到节点后再做转移，因此Trie树实际时间复杂度变为O(m*n)(其中n为每层数组中节点的数量)。这显然降低了查询效率,因此还算不上完善。

### HashTrie树
可变数组取词速度太慢，于是就有人想起用一组键值对（Java中可用HashMap类型，Python 中为 dict 类型，C#为Dictionary类型）代替可变数组：其中每个节点包含一组 Key-Value，每个 Key 对应该节点下的一个子节点字符，value 则指向相应的后一个状态。这种方式可以有效的减少空间浪费，同时由于键值对本质上就是一个哈希实现，因此理论上其查词效率也很高（理想状态下取词复杂度为O(1)）。
但是哈希有的缺点，这种实现的 Trie 树也会有：
   为了尽可能的避免键值冲突，哈希表需要额外的空间避开碰撞，因此仍有一部分的空间会被浪费；
   哈希表很难做到完美，尤其是数据体量增大之后，其查词复杂度常常难以维持在O(1)，同时，对哈希值的计算也需要额外的时间，因此实际查询效率要比经典实现低，其具体复杂度由相应的哈希实现来定。
与数组和可变数组实现相比，这种实现做到了空间和时间上的一种平衡，这个结果并不意外，因为哈希表本身就是平衡数组（查寻迅速、增删悲剧）和可变数组（增删迅速，查询悲剧）相应优点和缺点的一种数据结构。

总体而言，Hash Trie 结构简单，性能堪用，而且由于哈希实现可以为每个节点分配唯一的id,因此可以做到节点的实时动态添加（这点是非常大的优势）因此对于中小规模的词典或者对词典的实时更新有需求的应用，该实现非常适合。

### Double-arrayTrie树
双数组Trie树是目前Trie树各种实现中性能和存储空间均达到很好效果的实现。
#### 双数组trie树的构建
之所以叫双数组trie树，是因为它只用base[]和check[]两个数组就将整个trie的信息储存了起来，这两个数组的构建规则是：
                                        `base[i] + code(x) = j`
                                        `check[j] = i`
其中i，j都是base array的index，base array的长度是trie树中节点的个数，每个节点在base array中都有一个对应的index。

`base[]数组用于记录跳转结构，base array中index为i的那个节点，如果按照字符x转移，会转移到index为j的节点`
`check[]数组用于标识出base array 中每个状态的前一个状态，其主要作用是检验按base做转移的转移正确性`
`code(x)是字符x的编码，现实中为了方便通常直接用char code`
#### 构建base array
“清华”、“清华大学”、“清新”、“中华”、“华人”五个词，构成的trie树如下图所示：
{%image https://images.xianhu.wang/trie01.png %}

假设例树的字符编码表为：

| char |  清  |  华  |  大  |  学  |  新  |  中  |  人  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| code |  1   |  2   |  3   |  4   |  5   |  6   |  7   |

初始化root的base index为0，base值记为1。首先看root的所有子节点"清，中，华"：

-  base[0] + code(清) = 2，此时位置2空闲，因此“清”放入位置2
-  base[0] + code(中) = 7，此时位置7空闲，因此“中”放入位置7
-  base[0] + code(华) = 3，此时位置3空闲，因此“华”放入位置3

目前base array的情况如下：

| position |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|   char   | root |      |  清  |  华  |      |      |      |  中  |      |      |      |
|   base   |  1   |      |      |      |      |      |      |      |      |      |      |

 

- **`每次遍历完一个节点的所有子节点，只可以确认当前节点的base值，以及它的子节点的index位置`**
- **`子节点的base值此时会默认继承当前节点的base值，但在遍历子节点的子节点时，一旦有冲突，子节点的base值就会做相应修改`**

接下来遍历第二层的节点"华，新，华，人"：

- base[2] + code(华) = 3，冲突！因此 base[2] 修改为2；base[2] + code(华) = 4，可用，因此 “清华” 放入位置4
- base[2] + code(新) = 7，冲突！因此 base[2] 修改为3；base[2] + code(新) = 8，可用，因此 “清新” 放入位置8
- 因为base[2] 再次北被修改，所以“清华”的位置要重新计算：base[2] + code(华) = 5，可用，因此 “清华” 放入位置5
- base[7] + code(华) = 3，冲突！因此 base[7] 修改为2；base[7] + code(华) = 4，可用，因此 “中华” 放入位置4
- base[3] + code(人) = 8，冲突！因此 base[3] 修改为2；base[3] + code(人) = 9，可用，因此 “华人” 放入位置9

目前base array的情况如下：

| position | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| char     | root |      | 清   | 华   | 中华 | 清华 |      | 中   | 清新 | 华人 |      |
| base     | 1    |      | 3    | 2    |      |      |      | 2    |      |      |      |

接下来遍历第三层的节点"大"：

- base[5] + code(大) = 6，可用；因此 “清华大” 放入位置6

目前base array的情况如下：

| position |  0   |  1   |  2   |  3   |  4   |  5   |   6    |  7   |  8   |  9   |    10    |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :----: | :--: | :--: | :--: | :------: |
|   char   | root |      |  清  |  华  | 中华 | 清华 | 清华大 |  中  | 清新 | 华人 | 清华大学 |
|   base   |  1   |      |  3   |  2   |      |      |        |  2   |  3   |      |          |

接下来遍历第四层的节点"学"：

- base[6] + code(学) = 7，冲突！base[6] 修改为4
- base[6] + code(学) = 8，还是冲突！base[6] 修改为5
- base[6] + code(学) = 9，还是冲突！base[6] 修改为6
- base[6] + code(学) = 10，可用，因此 “清华大学” 放入位置10

目前base array的情况如下：

| position |  0   |  1   |  2   |  3   |  4   |  5   |   6    |  7   |  8   |  9   |    10    |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :----: | :--: | :--: | :--: | :------: |
|   char   | root |      |  清  |  华  | 中华 | 清华 | 清华大 |  中  | 清新 | 华人 | 清华大学 |
|   base   |  1   |      |  3   |  2   |      |      |   6    |  2   |  3   |      |          |

此时节点已经遍历完，**剩余base值未确定的都是尾节点了，因为它们都没用子节点了，所以不存在位置冲突，因此可以直接继承父节点的base值**：

| position |  0   |  1   |  2   |  3   |  4   |  5   |   6    |  7   |  8   |  9   |    10    |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :----: | :--: | :--: | :--: | :------: |
|   char   | root |      |  清  |  华  | 中华 | 清华 | 清华大 |  中  | 清新 | 华人 | 清华大学 |
|   base   |  1   |      |  3   |  2   |  2   |  3   |   6    |  2   |  3   |  2   |    6     |



#### 构建check array

check array的构建比较简单，只需要将子节点index的check值设为父节点的base值即可，所以有：

| position |  0   |  1   |  2   |  3   |  4   |  5   |   6    |  7   |  8   |  9   |    10    |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :----: | :--: | :--: | :--: | :------: |
|   char   | root |      |  清  |  华  | 中华 | 清华 | 清华大 |  中  | 清新 | 华人 | 清华大学 |
|   base   |  1   |      |  3   |  2   |  2   |  3   |   6    |  2   |  3   |  2   |    6     |
|  check   |  -2  |      |  0   |  0   |  7   |  2   |   5    |  0   |  2   |  3   |    6     |

#### 双数组trie树的查询

此时如果有一个词“清中”，我们要查询它是否在双数组trie里面，那么首先从root出发，由于“清”的code是1，因此会走到 
base[0]+code(清) = 2，
这里要用check数组检查位置3上的节点其父节点是否是位置0上的节点：check[2] = 0，等式成立！
然后继续看“中”：base[2]+code(中) = 9，
再检查位置9上的节点的父节点是否是位置2上的节点：check[9] = 3 !=2 ，
检查发现不满足，因此"清中"不在该trie里面。



