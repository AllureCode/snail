#  JVM笔记

## GC

### 什么是GC？

垃圾是指在运行程序中没有任何指针指向的对象。

### 为什么需要GC？

如果不进行GC内存可能会被耗尽，从而导致应用程序无法正常进行。

### 早期GC

在c/c++时代，垃圾回收是通过手动进行的。使用new进行内存的分配，使用delete进行释放。虽然这种方式可以很灵活的控制GC回收时间，但是频繁的申请和释放会给程序员造成压力，而且如果遗忘一处则可能导致内存泄露。最后导致OOM。

### Java垃圾回收算法

#### 引用计算算法（垃圾标记阶段）

内部维护了一个引用计数器，当对象被引用时就加1，引用失效就减1。当数值为0则表示可以被回收。但是无法解决循环引用的问题。

优点：实现简单，垃圾对象便于识别；判定效率高，回收没有延迟性。

缺点：需要单独的字段存储计数器，增加了存储空间的开销。每次赋值都需要对计数器进行更新，增加时间的开销。无法解决循环引用（导致java不使用这种算法）。

python中使用了引用计数算法：

解决方式：使用弱引用weakref解决。

#### 可达性分析算法（垃圾标记阶段-根搜索算法）

可达性分析算法是以根对象（GC Roots）为起始点，按照从上到下的方式搜索被根对象集合所连接的目标对象是否可达。

使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接的连接着，走过的路径称为引用链。

如果目标对象没有任何引用链相连，则是不可达，可被标记为垃圾。

那些对象可以是GC Roots：

虚拟机栈中引用的对象；本地方法栈JNI（本地方法）引用对象；方法区中静态属性引用的对象；方法区中常量引用的对象；所有被同步锁synchronized持有的对象；Java虚拟机的内部引用。

#### 对象的finalization机制

由于finalization机制的存在，一个无法被触及的对象可能在某一条件下复活自己。

因此finalization机制有三种状态：

**可触及的:**从根节点开始，可以到达对象

**可复活的：**对象的所有引用都被释放，但是可能在finalize()中复活

**不可触及的：**对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象无法被复活，因为finalize()方法只会被调用一次。所以只有当对象为不可触及时才可以被判定为垃圾。

##### 判定为垃圾

判定一个对象是否为垃圾，至少经历两次标记过程。

1.如果一个对象不存在引用链，则会进行一次标记。

2.判断对象是否有必要执行finalize()方法：

 2.1如果一个对象没有重写finalize()方法或者finalize()方法已经被虚拟机调用完成，则虚拟机视为没有必要执行，则对象被判定为不可触及。

 2.2如果对象重写了finalize()方法，且还未执行过，那么对象会被插入到F-Queue队列，由一个虚拟机自动创建的，低优先级的Finalizer线程触发其finalize()方法

 2.3finalize()方法是一个对象逃脱被回收的最后机会。稍后GC会对F-Queue队列中对象进行第二次标记，如果再次标记时对象在finalize()方法中与引用链上任何一个对象建立了联系，那么则会被移出即将回收的集合。

#### 标记-清除算法【Mark-Sweep】（清除阶段）

##### 执行过程

 当堆中的有效空间被耗尽的时候，就会停止整个应用程序（STW）然后进行标记和清除。

**标记**：Collector从引用根节点开始遍历，<font style="color:red">标记所有被引用的对象。一般是在对象Header中被记录为可达的对象。</font>>

**清除**：Collector对堆内存从头到尾进行线性遍历，如果发现某个对象在Header中没有被标记为可达对象，则将其回收。

##### 缺点

效率低，进行GC时会暂停整个应用程序导致用户体验感差；清除后的空间是不连续的，产生内存碎片，要维护一个空闲链表。

<font style="color:red">注意：</font>清除不是真正的清除，而是将要清除的对象地址保存在空闲的地址链表中，下次需要存取新对象时直接覆盖即可。

#### 复制算法

##### 核心思想

将活着的内存空间分成两块，每次只使用其中的一块，在垃圾回收时将正在使用的内存中的存活对象复制到未使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。

##### 优点

没有标记和清除过程，实现简单，运行高效。

复制过去之后保证空间连续性，不会出现“碎片”问题。

##### 缺点

需要两倍的内存地址。

对于G1这种分拆成大量region的GC，复制而不是移动，意味着GC需要维护region之间的对象引用关系，不管是内存占用还是时间开销都很大。

<font style="color:red">注意:</font>如果系统中的垃圾对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量不会太大（存活对象很低才行）。适合在新生代使用。

#### 标记压缩（标记整理）算法

##### 执行过程

第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象。

第二阶段将所有的存活对象压缩到内存的另一边，按顺序排放。然后在进行清除。

<font style="color:red">其实标记压缩算法就相当于标记清除算法+内存碎片整理。他与标记清除算法的区别在于：标记压缩算法是移动式的，标记清除算法是非移动式的。</font>

##### 优点

消除了标记清除算法中内存区域分散的问题。

消除了复制算法中空间减半的问题。

##### 缺点

效率低于复制算法，移动对象时，如果对象被其他对象所引用则还需要调整引用的地址。

移动过程中会暂停全部用户线程，所以会出现STW。

#### 分代收集算法

​      当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法并无新的方法，只是根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。

#### 标记清除-标记压缩-复制算法的对比

|          | 标记清除           | 标记压缩         | 复制                       |
| -------- | ------------------ | ---------------- | -------------------------- |
| 速度     | 中等               | 最慢             | 最快                       |
| 空间开销 | 少（但会堆积碎片） | 少（不堆积碎片） | 需要两倍空间（不堆积碎片） |
| 移动对象 | 否                 | 是               | 是                         |



## GC优化

### GC优化的目标

**响应速度：**响应速度指程序或系统对一个请求的响应有多迅速。比如，用户订单查询响应时间，对响应速度要求很高的系统，较大的停顿时间是不可接受的。调优的重点是在短的时间内快速响应

**吞吐量：** 吞吐量关注在一个特定时间段内应用系统的最大工作量，例如每小时批处理系统能完成的任务数量，在吞吐量方面优化的系统，较长的GC停顿时间也是可以接受的，因为高吞吐量应用更关心的是如何尽可能快地完成整个任务，不考虑快速响应用户请求。

### GC 事件分类

- **Young GC**

​         新生代内存的垃圾收集事件称为 Young GC（又称 Minor GC），当 JVM 无法为新对象分配在新生代内存空间时总会触发 Young GC。比如 Eden 区占满时，新对象分配频率越高，Young GC 的频率就越高。Young GC 每次都会引起全线停顿（Stop-The-World），暂停所有的应用线程，停顿时间相对老年代 GC 造成的停顿，几乎可以忽略不计。

- **Old GC**

​         只清理老年代空间的 GC 事件，只有 CMS 的并发收集是这个模式。

- **Full GC**

​         清理整个堆的 GC 事件，包括新生代、老年代、元空间等 。

- **Mixed GC**

​         清理整个新生代以及部分老年代的 GC，只有 G1 有这个模式。

###  GC收集器分类

| GC收集器          | 作用位置      | 使用的收集算法 | 特点                                                         | 应用场景                                                     |
| ----------------- | ------------- | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Serial            | 新生代        | 采用复制算法   | 针对新生代，采用复制算法，单线程收集，存在STW。              | 单线程简单高效，适合在一些桌面应用场景中。在用户的桌面应用场景中，可用内存一般不大（几十M至一两百M），可以在较短时间内完成垃圾收集,只要不频繁发生，是可以接受的。 |
| ParNew            | 新生代        | 采用复制算法   | 针对新生代，采用复制算法，多线程收集，存在STW。              | 在Server模式下，ParNew收集器是一个非常重要的收集器，因为除Serial外，目前只有它能与CMS收集器配合工作； 但在单个CPU环境中，不会比Serail收集器有更好的效果，因为存在线程交互开销。 |
| Parallel Scavenge | 新生代        | 采用复制算法   | 新生代垃圾收集器，采用复制算法，多线程，关注的目标是达到一个可控的吞吐量。 | 高吞吐量为目标，即减少垃圾收集时间，让用户代码获得更长的运行时间； 当应用程序运行在具有多个CPU上，对暂停时间没有特别高的要求时，即程序主要在后台进行计算，而不需要与用户进行太多交互； 例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序； |
| Serial Old        | 老年代        | 标记-整理算法  | 针对老年代； 采用"标记-整理"算法；单线程收集；               | 主要用于Client模式；而在Server模式有两大用途：在JDK1.5及之前，与Parallel Scavenge收集器搭配使用（JDK1.6有Parallel Old收集器可搭配）；作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用； |
| Parallel Old      | 老年代        | 标记-整理算法  | 针对老年代；采用"标记-整理"算法；多线程收集；                | 在Server模式，多CPU的情况下；在注重吞吐量以及CPU资源敏感的场景，就有了Parallel Scavenge加Parallel Old收集器的应用组合； |
| CMS               | 老年代        | 标记-清除算法  | 针对老年代；基于"标记-清除"算法(不进行压缩操作，产生内存碎片)；   以获取最短回收停顿时间为目标；并发收集、低停顿；需要更多的内存。第一次实现了让垃圾收集线程与用户线程（基本上）同时工作； | 与用户交互较多的场景；希望系统停顿时间最短，注重服务的响应速度以给用户带来较好的体验；如常见WEB、B/S系统的服务器上的应用； |
| G1                | 新生代+老年代 | 分代收集       | 并行与并发。能充分利用多CPU、多核环境下的硬件优势；可以并行来缩短"Stop The World"停顿时间；也可以并发让垃圾收集与用户程序同时进行；分代收集，收集范围包括新生代和老年代 。能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配； 能够采用不同方式处理不同时期的对象；结合多种垃圾收集算法，空间整合，不产生碎片。 <font color='red'>从整体看，是基于标记-整理算法；从局部（两个Region间）看，是基于复制算法；</font>可预测的停顿：低停顿的同时实现高吞吐量。 G1除了追求低停顿处，还能建立可预测的停顿时间模型；还可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒； | 面向服务端应用，针对具有大内存、多处理器的机器；最主要的应用是为需要低GC延迟，并具有大堆的应用程序提供解决方案； 在下面的情况时，使用G1可能比CMS好：（1）、超过50％的Java堆被活动数据占用；（2）、对象分配频率或年代提升频率变化很大；（3）、GC停顿时间过长（长于0.5至1秒）。 |

#### Serial 收集器

Seiral GC是最简单的GC，是一种在单核环境下运行的串行回收器。Seiral GC在回收对象时，其他正在工作的线程都必须暂停，因此在生产环境中几乎不被使用。但显然Seiral GC是各项开销最小的GC。

特点：针对新生代，采用复制算法，单线程收集，存在STW。

应用场景：单线程简单高效，适合在一些桌面应用场景中。在用户的桌面应用场景中，可用内存一般不大（几十M至一两百M），可以在较短时间内完成垃圾收集,只要不频繁发生，是可以接受的。

设置参数： 

"-XX:+UseSerialGC"：添加该参数来显式的使用串行垃圾收集器；

-XX:+UseParNewGC 新生代使用 ParNew 回收器，老年代使用串行收集器。

-XX:+UseParallelGC 新生代使用 ParallelGC 回收器，老年代使用串行收集器。

#### ParNew收集器

ParNew垃圾收集器是Serial收集器的多线程版本。

特点：针对新生代，采用复制算法，多线程收集，存在STW。

应用场景： 在Server模式下，ParNew收集器是一个非常重要的收集器，因为除Serial外，目前只有它能与CMS收集器配合工作； 但在单个CPU环境中，不会比Serail收集器有更好的效果，因为存在线程交互开销。

设置参数：

  "-XX:+UseConcMarkSweepGC"：指定使用CMS后，会默认使用ParNew作为新生代收集器；

   "-XX:+UseParNewGC"：强制指定使用ParNew；  

   "-XX:ParallelGCThreads"：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同；这个参数是指定并行 GC 线程的数量，一般最好和 CPU 核心数量相当。默认情况下，当 CPU 数量小于8， ParallelGCThreads 的值等于 CPU 数量，当 CPU 数量大于 8 时，则使用公式：3+（（5*CPU）/ 8）；同时这个参数只要是并行 GC 都可以使用，不只是 ParNew。

#### Parallel Scavenge收集器

 Parallel Scavenge垃圾收集器因为与吞吐量关系密切，也称为吞吐量收集器。

特点：新生代垃圾收集器，采用复制算法，多线程，关注的目标是达到一个可控的吞吐量。

应用场景：高吞吐量为目标，即减少垃圾收集时间，让用户代码获得更长的运行时间； 当应用程序运行在具有多个CPU上，对暂停时间没有特别高的要求时，即程序主要在后台进行计算，而不需要与用户进行太多交互； 例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序；

设置参数：

"-XX:MaxGCPauseMillis"：控制最大垃圾收集停顿时间，   MaxGCPauseMillis设置得稍小，停顿时间可能会缩短，但也可能会使得吞吐量下降；可能导致垃圾收集发生得更频繁；

"-XX:GCTimeRatio"：设置垃圾收集时间占总时间的比率，0<n<100的整数；  GCTimeRatio相当于设置吞吐量大小；垃圾收集执行时间占应用程序执行时间的比例的计算方法是：1 / (1 + n) 例如，选项-XX:GCTimeRatio=19，设置了垃圾收集时间占总时间=1/(1+19)；

"-XX:+UseAdptiveSizePolicy"： 开启这个参数后，就不用手工指定一些细节参数，如：新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold） 。JVM会根据当前系统运行情况收集性能监控信息，动态调整这些参数，以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略。

#### Serial Old收集器

 Serial Old是 Serial收集器的老年代版本。

特点：针对老年代； 采用"标记-整理"算法；单线程收集；

应用场景：

 主要用于Client模式；而在Server模式有两大用途：在JDK1.5及之前，与Parallel Scavenge收集器搭配使用（JDK1.6有Parallel Old收集器可搭配）；作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用；

#### Parallel Old收集器

 Parallel Old垃圾收集器是Parallel Scavenge收集器的老年代版本；JDK1.6中才开始提供；

特点： 针对老年代；采用"标记-整理"算法；多线程收集；

应用场景：在Server模式，多CPU的情况下；在注重吞吐量以及CPU资源敏感的场景，就有了Parallel Scavenge加Parallel Old收集器的应用组合；

设置参数： 

 "-XX:+UseParallelOldGC"：指定使用Parallel Old收集器；

#### CMS收集器

 并发标记清理（Concurrent Mark Sweep，CMS）收集器也称为并发低停顿收集器或低延迟垃圾收集器；

特点：针对老年代；基于"标记-清除"算法(不进行压缩操作，产生内存碎片)；   以获取最短回收停顿时间为目标；并发收集、低停顿；需要更多的内存。第一次实现了让垃圾收集线程与用户线程（基本上）同时工作；

应用场景：与用户交互较多的场景；希望系统停顿时间最短，注重服务的响应速度以给用户带来较好的体验；如常见WEB、B/S系统的服务器上的应用；

设置参数： 

"-XX:+UseConcMarkSweepGC"：指定使用CMS收集器；

-XX:-CMSPrecleaningEnabled 不进行预清理，CMS 在并发标记和重新标记的这段时间内，会有一个预清理的工作，而这个通过会尝试5秒之内等待来一次 YGC。以免在后面的重新标记阶段耗费大量时间来标记新生代的对象。

-XX:ParallelGCThreads 由于是并行处理器，当然也可以指定线程数。默认并发线程数是：（ParallelGCThreads + 3）/ 4）。

-XX:CMSInitiatingOccupancyFraction 由于 CMS 回收器不是独占式的，在垃圾回收的时候应用程序仍在工作，所以需要留出足够的内存给应用程序，否则会触发 FGC。而什么时候运行 CMS GC 呢？通过该参数即可设置，该参数表示的是老年代的内存使用百分比。当达到这个阈值就会执行 CMS。默认是68。 如果老年代内存增长很快，建议降低阈值，避免 FGC，如果增长慢，则可以加大阈值，减少 CMS GC 次数。提高吞吐量。

-XX：+UseCMSCompactAtFullCollection 由于 CMS 使用标记清理算法，内存碎片无法避免。该参数指定每次 CMS 后进行一次碎片整理。

#### G1收集器

G1（Garbage-First）是JDK7-u4才推出商用的收集器；G1最主要的设计目标是: **实现可预期及可配置的STW停顿时间**。从JDK9开始，JVM使用G1 GC作为默认的垃圾回收器。

特点：并行与并发。能充分利用多CPU、多核环境下的硬件优势；可以并行来缩短"Stop The World"停顿时间；也可以并发让垃圾收集与用户程序同时进行；

分代收集，收集范围包括新生代和老年代 。能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配； 能够采用不同方式处理不同时期的对象；

结合多种垃圾收集算法，空间整合，不产生碎片。 从整体看，是基于标记-整理算法；从局部（两个Region间）看，是基于复制算法；

可预测的停顿：低停顿的同时实现高吞吐量。 G1除了追求低停顿处，还能建立可预测的停顿时间模型；还可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒；

应用场景：面向服务端应用，针对具有大内存、多处理器的机器；最主要的应用是为需要低GC延迟，并具有大堆的应用程序提供解决方案； 在下面的情况时，使用G1可能比CMS好：（1）、超过50％的Java堆被活动数据占用；（2）、对象分配频率或年代提升频率变化很大；（3）、GC停顿时间过长（长于0.5至1秒）。

设置参数：  

   "-XX:+UseG1GC"：指定使用G1收集器；

   "-XX:InitiatingHeapOccupancyPercent"：当整个Java堆的占用率达到参数值时，开始并发标记阶段；默认为45；

   "-XX:MaxGCPauseMillis"：为G1设置暂停时间目标，默认值为200毫秒；

   "-XX:G1HeapRegionSize"：设置每个Region大小，范围1MB到32MB；目标是在最小Java堆时可以拥有约2048个Region；

​	-XX:InitiatingHeapOccupancyPercent 该参数可以指定当整个堆使用率达到多少时，触发并发标记周期的执行。默认值时45，即当堆的使用率达到45%，执行并发标记周期，该值一旦设置，始终都不会被 G1修改。也就是说，G1 就算为了满足 MaxGCPauseMillis 也不会修改此值。如果该值设置的很大，导致并发周期迟迟得不到启动，那么引起 FGC 的几率将会变大。如果过小，则会频繁标记，GC 线程抢占应用程序CPU 资源，性能将会下降。

##### G1调优注意点

G1的正常处理流程中没有Full GC，只有在垃圾回收处理不过来(或者主动触发)时才会出现， G1的Full GC就是单线程执行的Serial old gc，会导致非常长的STW，是调优的重点，需要尽量避免Full GC，常见原因如下：

- 程序主动执行System.gc()

- 全局并发标记期间老年代空间被填满（并发模式失败：新生代发生垃圾回收，同时老年代又没有足够的空间容纳晋升的对象）

- Mixed GC期间老年代空间被填满（晋升失败：当新生代发生垃圾回收，老年代有足够的空间可以容纳晋升的对象，但是由于空闲空间的碎片化，导致晋升失败）

- Young GC时Survivor空间和老年代没有足够空间容纳存活对象

  类似CMS，常见的解决是：

  增大-XX:ConcGCThreads=n 选项增加并发标记线程的数量或者STW期间并行线程的数量：-XX:ParallelGCThreads=n

  减小-XX:InitiatingHeapOccupancyPercent 提前启动标记周期

  增大预留内存 -XX:G1ReservePercent=n ，默认值是10，代表使用10%的堆内存为预留内存，当Survivor区域没有足够空间容纳新晋升对象时会尝试使用预留内存

  **巨型对象分配**

  巨型对象区中的每个Region中包含一个巨型对象，剩余空间不再利用，导致空间碎片化，当G1没有合适空间分配巨型对象时，G1会启动串行Full GC来释放空间。可以通过增加 -XX:G1HeapRegionSize来增大Region大小，这样一来，相当一部分的巨型对象就不再是巨型对象了，而是采用普通的分配方式。

  **不要设置Young区的大小**

  原因是为了尽量满足目标停顿时间，逻辑上的Young区会进行动态调整。如果设置了大小，则会覆盖掉并且会禁用掉对停顿时间的控制。

  **平均响应时间设置**

  使用应用的平均响应时间作为参考来设置MaxGCPauseMillis，JVM会尽量去满足该条件，可能是90%的请求或者更多的响应时间在这之内， 但是并不代表是所有的请求都能满足，平均响应时间设置过小会导致频繁GC。

  ## 通用参数

  | 参数                                | 作用                                                         |
  | ----------------------------------- | ------------------------------------------------------------ |
  | -XX:-+DisableExplicitGC             | 禁用 System.gc()，由于该方法默认会触发 FGC，并且忽略参数中的 UseG1GC 和 UseConcMarkSweepGC，因此必要时可以禁用该方法。 |
  | -XX:+ExplicitGCInvokesConcurrent    | 该参数可以改变上面的行为，也就是说，System.gc() 后不使用 FGC ，而是使用配置的并发收集器进行并发收集。注意：使用此选项就不要使用上面的选项。 |
  | -XX:-ScavengeBeforeFullGC           | 由于大部分 FGC 之前都会 YGC，减轻了 FGC 的压力，缩短了 FGC 的停顿时间，但也可能你不需要这个特性，那么你可以使用这个参数关闭，默认是 ture 开启。 |
  | -XX:MaxTenuringThreshold={value}    | 新生代 to 区的对象在经过多次 GC 后，如果还没有死亡，则认为他是一个老对象，则可以晋升到老年代，而这个年龄（GC 次数）是可以设置的，有就是这个参数。默认值时15。超过15 则认为是无限大(因为age变量时4个 bit，超过15无法表达)。但该参数不是唯一决定对象晋升的条件。当 to 区不够或者改对象年龄已经达到了平均晋升值或者大对象等条件。 |
  | -XX:TargetSurvivorRatio={value}     | 决定对何时晋升的不仅只有 XX:MaxTenuringThreshold 参数，如果在 Survivor 空间中相同年龄所有对象大小的总和大鱼 Survivor 空间的一半（默认50%），年龄大于或等于该年龄的对象就可以直接进入老年代。无需在乎 XX:MaxTenuringThreshold参数。因此，MaxTenuringThreshold 只是对象晋升的最大年龄。如果将 TargetSurvivorRatio 设置的很小，对象将晋升的很快。 |
  | -XX:PretenureSizeThresholds={value} | 除了年龄外，对象的体积也是影响晋升的一个关键，也就是大对象。如果一个对象新生代放不下，只能直接通过分配担保机制进入老年代。该参数是设置对象直接晋升到老年代的阈值，单位是字节。只要对象的大小大于此阈值就会直接绕过新生代直接进入老年代。注意：**这个参数只对 Serial 和 ParNew 有效，ParallelGC 无效**，默认情况下该值为0，也就是不指定最大的晋升大小，一切有运行情况决定。 |
  | -XX:-UseTLAB                        | 禁用线程本地分配缓存。TLAB 的全称是 Thread LocalAllocation Buffer ，即线程本地线程分配缓存，是一个线程私有的内存区域。该设计是为了加速对象分配速度。由于对象一般都是分配在堆上，而对是线程共享的。因此肯定有锁，虽然使用 CAS 的操作，但性能仍有优化空间。通过为每一个线程分配一个 TLAB 的空间（在 eden 区），可以消除多个线程同步的开销。默认开启。 |
  | -XX:TLABSize                        | 指定 TLAB 的大小。                                           |
  | -XX:+PrintTLAB                      | 跟踪 TLAB 的使用情况。用以确定是用多大的 TLABSize。          |
  | -XX:+ResizeTLAB                     | 自动调整 TLAB 大小。                                         |

  ### 优化步骤

  1.监控GC的状态：使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间确定是否进行优化。 如jstat，jmap，jinfo 命令。

  2.生成堆的dump文件：通过JMX的MBean生成当前的堆信息的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。

  3.分析dump文件

  4.分析结果，判断是否需要优化：如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化，如果GC时间超过1-3秒，或者频繁GC，则必须优化。

  <font style="color:red">如果满足下面的指标，则一般不需要进行GC：</font>

  - Minor GC执行时间不到50ms；
  - Minor GC执行不频繁，约10秒一次；
  - Full GC执行时间不到1s；
  - Full GC执行频率不算频繁，不低于10分钟1次；

  5.调整GC类型和内存分配：如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数。

  6.不断分析和调整：分析并找到最合适的参数，如果找到了最合适的参数，则将这些参数应用到所有服务器。

  ### 常用的GC优化策略

  **策略 1：**将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代，在实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当调节新生代大小，最大限度降低新对象直接进入老年代的情况。

  **策略 2：**大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得分析，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收是巨大的挑战）。-XX:PretenureSizeThreshold 可以设置直接进入老年代的对象大小。

  **策略 3：**合理设置进入老年代对象的年龄，-XX:MaxTenuringThreshold 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 full gc 发生的频率。

  **策略 4：**设置稳定的堆大小，堆大小设置有两个参数：-Xms 初始化堆大小，-Xmx 最大堆大小。

  ### 链接分享

  **关于美团的GC优化实践**：https://tech.meituan.com/2017/12/29/jvm-optimize.html

  **JVM参数调优**：http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html

  





